vmlinux map is loaded
Waiting for data race records


====================================================================================================================================================================================
Total: 2	Addresses: c10f7cd0 c262be1d
1	0xc10f7cc2: _static_cpu_has at /root/2017-7533-i386/linux-4.11/./arch/x86/include/asm/cpufeature.h:146
1	0xc262be1d: pv_queued_spin_unlock at /root/2017-7533-i386/linux-4.11/./arch/x86/include/asm/paravirt.h:674

1	c10f7cd0 __read_once_size T: trace_20241113_130544_2_3_37.txt S: 37 I1: 2 I2: 3 IP1: c262be1d IP2: c10f7cd0 PMA1: 363bd084 PMA2: 363bd084 CPU1: 1 CPU2: 0 R1: 0 R2: 1 L1: 1 L2: 4 IC1: 121080 IC2: 120946
1	c262be1d pv_queued_spin_unlock T: trace_20241113_130544_2_3_37.txt S: 37 I1: 2 I2: 3 IP1: c262be1d IP2: c10f7cd0 PMA1: 363bd084 PMA2: 363bd084 CPU1: 1 CPU2: 0 R1: 0 R2: 1 L1: 1 L2: 4 IC1: 121080 IC2: 120946

/root/snowboard-2017-15649/testsuite/kernel/2017-15649/source//./arch/x86/include/asm/cpufeature.h:146
       126	
       127	#define set_cpu_cap(c, bit)	set_bit(bit, (unsigned long *)((c)->x86_capability))
       128	#define clear_cpu_cap(c, bit)	clear_bit(bit, (unsigned long *)((c)->x86_capability))
       129	#define setup_clear_cpu_cap(bit) do { \
       130		clear_cpu_cap(&boot_cpu_data, bit);	\
       131		set_bit(bit, (unsigned long *)cpu_caps_cleared); \
       132	} while (0)
       133	#define setup_force_cpu_cap(bit) do { \
       134		set_cpu_cap(&boot_cpu_data, bit);	\
       135		set_bit(bit, (unsigned long *)cpu_caps_set);	\
       136	} while (0)
       137	
       138	#if defined(CC_HAVE_ASM_GOTO) && defined(CONFIG_X86_FAST_FEATURE_TESTS)
       139	/*
       140	 * Static testing of CPU features.  Used the same as boot_cpu_has().
       141	 * These will statically patch the target code for additional
       142	 * performance.
       143	 */
       144	static __always_inline __pure bool _static_cpu_has(u16 bit)
       145	{
==>    146			asm_volatile_goto("1: jmp 6f\n"       
       147				 "2:\n"
       148				 ".skip -(((5f-4f) - (2b-1b)) > 0) * "
       149				         "((5f-4f) - (2b-1b)),0x90\n"
       150				 "3:\n"
       151				 ".section .altinstructions,\"a\"\n"
       152				 " .long 1b - .\n"		/* src offset */
       153				 " .long 4f - .\n"		/* repl offset */
       154				 " .word %P1\n"			/* always replace */
       155				 " .byte 3b - 1b\n"		/* src len */
       156				 " .byte 5f - 4f\n"		/* repl len */
       157				 " .byte 3b - 2b\n"		/* pad len */
       158				 ".previous\n"
       159				 ".section .altinstr_replacement,\"ax\"\n"
       160				 "4: jmp %l[t_no]\n"
       161				 "5:\n"
       162				 ".previous\n"
       163				 ".section .altinstructions,\"a\"\n"
       164				 " .long 1b - .\n"		/* src offset */
       165				 " .long 0\n"			/* no replacement */
       166				 " .word %P0\n"			/* feature bit */

/root/snowboard-2017-15649/testsuite/kernel/2017-15649/source//./arch/x86/include/asm/paravirt.h:674
       654	{
       655		PVOP_VCALL0(pv_mmu_ops.lazy_mode.flush);
       656	}
       657	
       658	static inline void __set_fixmap(unsigned /* enum fixed_addresses */ idx,
       659					phys_addr_t phys, pgprot_t flags)
       660	{
       661		pv_mmu_ops.set_fixmap(idx, phys, flags);
       662	}
       663	
       664	#if defined(CONFIG_SMP) && defined(CONFIG_PARAVIRT_SPINLOCKS)
       665	
       666	static __always_inline void pv_queued_spin_lock_slowpath(struct qspinlock *lock,
       667								u32 val)
       668	{
       669		PVOP_VCALL2(pv_lock_ops.queued_spin_lock_slowpath, lock, val);
       670	}
       671	
       672	static __always_inline void pv_queued_spin_unlock(struct qspinlock *lock)
       673	{
==>    674		PVOP_VCALLEE1(pv_lock_ops.queued_spin_unlock, lock);       
       675	}
       676	
       677	static __always_inline void pv_wait(u8 *ptr, u8 val)
       678	{
       679		PVOP_VCALL2(pv_lock_ops.wait, ptr, val);
       680	}
       681	
       682	static __always_inline void pv_kick(int cpu)
       683	{
       684		PVOP_VCALL1(pv_lock_ops.kick, cpu);
       685	}
       686	
       687	static __always_inline bool pv_vcpu_is_preempted(long cpu)
       688	{
       689		return PVOP_CALLEE1(bool, pv_lock_ops.vcpu_is_preempted, cpu);
       690	}
       691	
       692	#endif /* SMP && PARAVIRT_SPINLOCKS */
       693	
       694	#ifdef CONFIG_X86_32


====================================================================================================================================================================================
Total: 8	Addresses: c10a9251 c112ad8a
2	0xc10a924e: compound_head at /root/2017-7533-i386/linux-4.11/./include/linux/page-flags.h:149
6	0xc112ad87: compound_head at /root/2017-7533-i386/linux-4.11/./include/linux/page-flags.h:149

2	c10a9251 atomic_inc T: trace_20241113_130542_3_3_60.txt S: 60 I1: 3 I2: 3 IP1: c10a9251 IP2: c112ad8a PMA1: 3685c63c PMA2: 3685c63c CPU1: 0 CPU2: 1 R1: 0 R2: 0 L1: 4 L2: 4 IC1: 126472 IC2: 124300
6	c112ad8a atomic_dec_and_test T: trace_20241113_130542_3_3_60.txt S: 60 I1: 3 I2: 3 IP1: c112ad8a IP2: c112ad8a PMA1: 3685c63c PMA2: 3685c63c CPU1: 0 CPU2: 1 R1: 0 R2: 0 L1: 4 L2: 4 IC1: 126596 IC2: 124300

++++++++++++++++++++++++
STATS: Distinct IPs: 4 Distinct pairs: 3 Distinct clusters: 2
++++++++++++++++++++++++
/root/snowboard-2017-15649/testsuite/kernel/2017-15649/source//./include/linux/page-flags.h:149
       129	
       130		/* SLOB */
       131		PG_slob_free = PG_private,
       132	
       133		/* Compound pages. Stored in first tail page's flags */
       134		PG_double_map = PG_private_2,
       135	
       136		/* non-lru isolated movable page */
       137		PG_isolated = PG_reclaim,
       138	};
       139	
       140	#ifndef __GENERATING_BOUNDS_H
       141	
       142	struct page;	/* forward declaration */
       143	
       144	static inline struct page *compound_head(struct page *page)
       145	{
       146		unsigned long head = READ_ONCE(page->compound_head);
       147	
       148		if (unlikely(head & 1))
==>    149			return (struct page *) (head - 1);       
       150		return page;
       151	}
       152	
       153	static __always_inline int PageTail(struct page *page)
       154	{
       155		return READ_ONCE(page->compound_head) & 1;
       156	}
       157	
       158	static __always_inline int PageCompound(struct page *page)
       159	{
       160		return test_bit(PG_head, &page->flags) || PageTail(page);
       161	}
       162	
       163	/*
       164	 * Page flags policies wrt compound pages
       165	 *
       166	 * PF_ANY:
       167	 *     the page flag is relevant for small, head and tail pages.
       168	 *
       169	 * PF_HEAD:

/root/snowboard-2017-15649/testsuite/kernel/2017-15649/source//./include/linux/page-flags.h:149
       129	
       130		/* SLOB */
       131		PG_slob_free = PG_private,
       132	
       133		/* Compound pages. Stored in first tail page's flags */
       134		PG_double_map = PG_private_2,
       135	
       136		/* non-lru isolated movable page */
       137		PG_isolated = PG_reclaim,
       138	};
       139	
       140	#ifndef __GENERATING_BOUNDS_H
       141	
       142	struct page;	/* forward declaration */
       143	
       144	static inline struct page *compound_head(struct page *page)
       145	{
       146		unsigned long head = READ_ONCE(page->compound_head);
       147	
       148		if (unlikely(head & 1))
==>    149			return (struct page *) (head - 1);       
       150		return page;
       151	}
       152	
       153	static __always_inline int PageTail(struct page *page)
       154	{
       155		return READ_ONCE(page->compound_head) & 1;
       156	}
       157	
       158	static __always_inline int PageCompound(struct page *page)
       159	{
       160		return test_bit(PG_head, &page->flags) || PageTail(page);
       161	}
       162	
       163	/*
       164	 * Page flags policies wrt compound pages
       165	 *
       166	 * PF_ANY:
       167	 *     the page flag is relevant for small, head and tail pages.
       168	 *
       169	 * PF_HEAD:


